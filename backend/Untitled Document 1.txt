import fs from "fs";
import https from "https";
import express from "express";
import { Server as CreateSocketServer } from "socket.io";
const app = express();
//we need a key and cert to run https

//we generated them with mkcert
// $ mkcert create-ca
// $ mkcert create-cert
const key = fs.readFileSync("cert.key");
const cert = fs.readFileSync("cert.crt");

//we changed our express setup so we can use https
//pass the key and cert to createServer on https
const expressServer = https.createServer({ key, cert }, app);
//create our socket.io server... it will listen to our express port
const io = new CreateSocketServer(expressServer, {
  cors: {
    origin: [
      "https://localhost",
      "https://192.168.0.195", //if using a phone or another computer
    ],
    methods: ["GET", "POST"],
  },
});

//listen to our express server
expressServer.listen(8180, () => {
  console.log("🛰️ signalling server listening on  port 8180");
});

//offers will contain {}
const offers = [
  // offererUserId
  // offer
  // offerIceCandidates
  // answererUserId
  // answer
  // answererIceCandidates
];
const connectedSockets = [
  //userId, socketId
];

io.on("connection", (socket) => {
  const userId = socket.handshake.auth.userId;
  const token = socket.handshake.auth.token;

  // middleware for the token
  if (token !== "xyz") {
    socket.disconnect(true);
    return;
  }

  // push the socket details into connectedSocket array
  connectedSockets.push({ userId, socketId: socket.id });

  // listen for new offers
  socket.on("newOffer", ({ newOffer, sendToUserId }) => {
    const newOfferObj = {
      offererUserId: userId,
      offer: newOffer,
      offerIceCandidates: [],
      answererUserId: null,
      answer: null,
      answerIceCandidates: [],
    };

    offers.push(newOfferObj);

    // get the socket id to whom the offer to be sent
    const sendToSocket = connectedSockets.find(
      (socket) => socket.userId === sendToUserId
    );

    if (!sendToSocket) {
      console.log("No matching user socket found");
      return;
    }

    // emit the offer to the client2
    socket.to(sendToSocket.socketId).emit("newOfferAwaiting", newOfferObj);
  });

  // listen for new answers
  socket.on("newAnswer", (offerObj, ackFunction) => {
    // emit the answer offer back to client1, so first search for client1 socket
    const socketToAnswer = connectedSockets.find((client) => {
      return client.userId === offerObj.offererUserId;
    });

    if (!socketToAnswer) {
      console.log("No matching offerer object found");
    }

    // get the socket id of client1(offerer)
    const socketIdToAnswer = socketToAnswer.socketId;

    // now get the offer object of the client1(offerer) and update the object
    const offerToUpdate = offers.find(
      (offer) => offer.offererUserId === offerObj.offererUserId
    );

    if (!offerToUpdate) {
      console.log("No offer object found to update");
    }

    // send the ice candidate of offerer(client1) back to answerer
    ackFunction(offerToUpdate.offerIceCandidates);

    //update the offer object with the new answer
    offerToUpdate.answer = offerObj.answer;
    offerToUpdate.answererUserId = userId;

    // send the udpated offer with answer back to client1(offerer)
    socket.to(socketIdToAnswer).emit("answerResponse", offerToUpdate);
  });

  // listen for new ice candidates
  socket.on("sendIceCandidateToSignalingServer", (iceCandidateObj) => {
    const { didIOffer, iceUserId, iceCandidate } = iceCandidateObj; // destructuring the object

    // if the ice candidate where sent by the offerer
    if (didIOffer) {
      // find the offer object in offers to updatethe icecandidates with
      const offerToUpdate = offers.find(
        (offer) => offer.offererUserId === iceUserId
      );
      if (offerToUpdate) {
        offerToUpdate.offerIceCandidates.push(iceCandidate);
      }
      // now what if the answerer ice candidates already exists before the offerer so in this case send all the answerer ice candidated to answerer
      if (offerToUpdate.answererUserId) {
        const socketToSendTo = connectedSockets.find(
          (socket) => socket.userId === offerToUpdate.answererUserId
        );

        // if the socket info is found then we emit ice candidates to answerer of current ice candidates of offerer
        if (socketToSendTo) {
          socket
            .to(socketToSendTo.socketId)
            .emit("receivedIceCandidateFromServer", iceCandidate);
        } else {
          console.log("ice candidates received but couldn't find the answerer");
        }
      }
    } else {
      // if didIOffer was false ie; the icecanidates were from answerer

      // find the offer object in offers
      const offerToUpdate = offers.find(
        (offer) => offer.answererUserId === iceUserId
      );

      if (!offerToUpdate) {
        console.log("couldn't find offer to update (didIOffer:false)");
      }

      // find the offerer socketId to
      const socketToSendTo = connectedSockets.find(
        (socket) => socket.userId === offerToUpdate.offererUserId
      );

      // emit the icecandidate to the offerer
      if (socketToSendTo) {
        socket
          .to(socketToSendTo.socketId)
          .emit("receivedIceCandidateFromServer", iceCandidate);
      } else {
        console.log(
          "ice candidate received but could not find offerer (didIOffer:false)"
        );
      }
    }
  });
});











//opti
import fs from "fs";
import https from "https";
import express from "express";
import { Server as CreateSocketServer } from "socket.io";
import { v4 as uuidv4 } from "uuid"; // Import the UUID library

const app = express();

// We need a key and cert to run HTTPS
// We generated them with mkcert
// $ mkcert create-ca
// $ mkcert create-cert
const key = fs.readFileSync("cert.key");
const cert = fs.readFileSync("cert.crt");

// Change our express setup so we can use HTTPS
// Pass the key and cert to createServer on HTTPS
const expressServer = https.createServer({ key, cert }, app);

// Create our Socket.io server... it will listen to our express port
const io = new CreateSocketServer(expressServer, {
  cors: {
    origin: [
      "https://localhost",
      "https://192.168.0.195", // if using a phone or another computer
    ],
    methods: ["GET", "POST"],
  },
});

// Listen to our express server
expressServer.listen(8180, () => {
  console.log("🛰️ Signaling server listening on port 8180");
});

// Offers will contain
const offers = [
  // offererUserId
  // offer
  // offerIceCandidates
  // answererUserId
  // answer
  // answererIceCandidates
];
const connectedSockets = new Map(); // Change to a Map for better management

io.on("connection", (socket) => {
  // Generate a unique user ID for each connection
  const userId = uuidv4();

  // Push the socket details into connectedSockets map
  connectedSockets.set(userId, { socketId: socket.id });

  // Send the user ID back to the client
  socket.emit("assignUserId", userId);

  // Listen for new offers
  socket.on("newOffer", ({ newOffer, sendToUserId }) => {
    const newOfferObj = {
      offererUserId: userId,
      offer: newOffer,
      offerIceCandidates: [],
      answererUserId: null,
      answer: null,
      answerIceCandidates: [],
    };

    offers.push(newOfferObj);

    // Get the socket id to whom the offer to be sent
    const sendToSocket = connectedSockets.get(sendToUserId);

    if (!sendToSocket) {
      console.log("No matching user socket found");
      return;
    }

    // Emit the offer to the client2
    socket.to(sendToSocket.socketId).emit("newOfferAwaiting", newOfferObj);
  });

  // Listen for new answers
  socket.on("newAnswer", (offerObj, ackFunction) => {
    // Emit the answer offer back to client1, so first search for client1 socket
    const socketToAnswer = connectedSockets.get(offerObj.offererUserId);

    if (!socketToAnswer) {
      console.log("No matching offerer object found");
      return;
    }

    // Get the socket id of client1(offerer)
    const socketIdToAnswer = socketToAnswer.socketId;

    // Now get the offer object of the client1(offerer) and update the object
    const offerToUpdate = offers.find(
      (offer) => offer.offererUserId === offerObj.offererUserId
    );

    if (!offerToUpdate) {
      console.log("No offer object found to update");
      return;
    }

    // Send the ICE candidate of offerer(client1) back to answerer
    ackFunction(offerToUpdate.offerIceCandidates);

    // Update the offer object with the new answer
    offerToUpdate.answer = offerObj.answer;
    offerToUpdate.answererUserId = userId;

    // Send the updated offer with answer back to client1(offerer)
    socket.to(socketIdToAnswer).emit("answerResponse", offerToUpdate);
  });

  // Listen for new ICE candidates
  socket.on("sendIceCandidateToSignalingServer", (iceCandidateObj) => {
    const { didIOffer, iceUserId, iceCandidate } = iceCandidateObj; // Destructuring the object

    // If the ICE candidate was sent by the offerer
    if (didIOffer) {
      // Find the offer object in offers to update the ICE candidates with
      const offerToUpdate = offers.find(
        (offer) => offer.offererUserId === iceUserId
      );

      if (offerToUpdate) {
        offerToUpdate.offerIceCandidates.push(iceCandidate);
      }

      // Now what if the answerer ICE candidates already exist before the offerer,
      // so in this case send all the answerer ICE candidates to the answerer
      if (offerToUpdate && offerToUpdate.answererUserId) {
        const socketToSendTo = connectedSockets.get(
          offerToUpdate.answererUserId
        );

        // If the socket info is found then we emit ICE candidates to the answerer
        if (socketToSendTo) {
          socket
            .to(socketToSendTo.socketId)
            .emit("receivedIceCandidateFromServer", iceCandidate);
        } else {
          console.log("ICE candidates received but couldn't find the answerer");
        }
      }
    } else {
      // If didIOffer was false, i.e., the ICE candidates were from the answerer

      // Find the offer object in offers
      const offerToUpdate = offers.find(
        (offer) => offer.answererUserId === iceUserId
      );

      if (!offerToUpdate) {
        console.log("Couldn't find offer to update (didIOffer: false)");
        return;
      }

      // Find the offerer socketId
      const socketToSendTo = connectedSockets.get(
        offerToUpdate.offererUserId
      );

      // Emit the ICE candidate to the offerer
      if (socketToSendTo) {
        socket
          .to(socketToSendTo.socketId)
          .emit("receivedIceCandidateFromServer", iceCandidate);
      } else {
        console.log(
          "ICE candidate received but could not find offerer (didIOffer: false)"
        );
      }
    }
  });

  // Handle socket disconnect
  socket.on("disconnect", () => {
    connectedSockets.delete(userId);
    console.log(`User with ID ${userId} disconnected`);
  });
});














